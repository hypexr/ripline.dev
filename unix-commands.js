// Simple Unix Command Emulator for RIPLINE Terminal
// Implements common Unix/Linux commands for browser-based terminal

class UnixEmulator {
    constructor() {
        // Default filesystem structure - realistic Unix/Linux system
        const defaultFileSystem = {
            '/': {
                'bin': {
                    'bash': '[binary]',
                    'ls': '[binary]',
                    'cat': '[binary]',
                    'grep': '[binary]',
                    'ps': '[binary]',
                    'chmod': '[binary]',
                    'chown': '[binary]'
                },
                'etc': {
                    'passwd': 'root:x:0:0:root:/root:/bin/bash\nkmitnick:x:1000:1000:Kevin Mitnick:/home/user/kmitnick:/bin/bash\n',
                    'shadow': 'root:!:19000:0:99999:7:::\nkmitnick:!:19000:0:99999:7:::\n',
                    'group': 'root:x:0:\nkmitnick:x:1000:\nwheel:x:10:kmitnick\nsudo:x:27:kmitnick\n',
                    'hostname': 'ripline\n',
                    'hosts': '127.0.0.1   localhost\n127.0.1.1   ripline\n\n# The following lines are desirable for IPv6 capable hosts\n::1     localhost ip6-localhost ip6-loopback\nff02::1 ip6-allnodes\nff02::2 ip6-allrouters\n',
                    'fstab': '# /etc/fstab: static file system information\n#\n# <file system> <mount point>   <type>  <options>       <dump>  <pass>\nproc            /proc           proc    defaults        0       0\nsysfs           /sys            sysfs   defaults        0       0\n',
                    'motd': 'Welcome to RIPLINE Development Server\n\nUnauthorized access is prohibited.\n\nFor support: hello@ripline.dev\n',
                    'issue': 'RIPLINE Linux 5.15.0 \\n \\l\n\n',
                    'resolv.conf': '# Generated by NetworkManager\nnameserver 8.8.8.8\nnameserver 8.8.4.4\n',
                    'ssh': {
                        'sshd_config': 'Port 22\nPermitRootLogin no\nPubkeyAuthentication yes\nPasswordAuthentication no\nChallengeResponseAuthentication no\nUsePAM yes\nX11Forwarding yes\nPrintMotd no\nAcceptEnv LANG LC_*\nSubsystem sftp /usr/lib/openssh/sftp-server\n'
                    }
                },
                'home': {
                    'user': {
                        'kmitnick': {
                            '.bashrc': '# ~/.bashrc: executed by bash for non-login shells\n\n# If not running interactively, don\'t do anything\ncase $- in\n    *i*) ;;\n      *) return;;\nesac\n\n# History settings\nHISTCONTROL=ignoreboth\nHISTSIZE=1000\nHISTFILESIZE=2000\n\n# Prompt\nPS1=\'\\u@\\h:\\w\\$ \'\n\n# Enable color support\nif [ -x /usr/bin/dircolors ]; then\n    alias ls=\'ls --color=auto\'\n    alias grep=\'grep --color=auto\'\nfi\n\n# Aliases\nalias ll=\'ls -alF\'\nalias la=\'ls -A\'\nalias l=\'ls -CF\'\n',
                            '.bash_history': 'ls -la\ncd projects\ngit status\nvi README.md\nsudo apt update\nhistory\n',
                            '.bash_logout': '# ~/.bash_logout: executed by bash when login shell exits\n\n# Clear console on logout\nif [ "$SHLVL" = 1 ]; then\n    [ -x /usr/bin/clear_console ] && /usr/bin/clear_console -q\nfi\n',
                            '.profile': '# ~/.profile: executed by the command interpreter for login shells\n\nif [ -n "$BASH_VERSION" ]; then\n    if [ -f "$HOME/.bashrc" ]; then\n        . "$HOME/.bashrc"\n    fi\nfi\n\n# Set PATH\nif [ -d "$HOME/bin" ] ; then\n    PATH="$HOME/bin:$PATH"\nfi\n',
                            '.ssh': {
                                'authorized_keys': 'ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQDKvH... kmitnick@ripline\n',
                                'known_hosts': 'github.com ssh-rsa AAAAB3NzaC1yc2EAAAABIwAAAQEAq2...\n'
                            },
                            'README.md': '# RIPLINE Development\n\nWelcome to the RIPLINE development server.\n\n## About\n\nWe build habit tracking apps and mobile games.\n\n## Current Projects\n\n- **I CAN HAS GOAL**: Habit tracking application\n- Mobile games (in development)\n\n## Contact\n\nEmail: hello@ripline.dev\n',
                            'projects': {
                                'icanhazgoal': {
                                    'README.md': '# I CAN HAS GOAL\n\nA powerful tool to build better habits and track your progress.\n\n## Features\n\n- Daily habit tracking\n- Progress visualization\n- Goal management\n- Streak tracking\n\n## Tech Stack\n\n- React Native\n- TypeScript\n- SQLite\n\n## Status\n\nIn active development.\n',
                                    'package.json': '{\n  "name": "icanhazgoal",\n  "version": "1.0.0",\n  "description": "Habit tracking application",\n  "main": "index.js",\n  "scripts": {\n    "start": "react-native start",\n    "test": "jest"\n  },\n  "dependencies": {\n    "react": "^18.2.0",\n    "react-native": "^0.72.0"\n  }\n}\n',
                                    '.gitignore': 'node_modules/\n.expo/\n.DS_Store\n*.log\n.env\n'
                                },
                                'website': {
                                    'index.html': '<!DOCTYPE html>\n<html>\n<head>\n  <title>RIPLINE</title>\n</head>\n<body>\n  <h1>RIPLINE Development</h1>\n</body>\n</html>\n',
                                    'style.css': 'body {\n  background: #000;\n  color: #0f0;\n  font-family: monospace;\n}\n'
                                }
                            },
                            'docs': {
                                'notes.txt': 'Development Notes\n==================\n\n2025-10-22:\n- Updated terminal interface\n- Added new filesystem structure\n- Improved command handling\n\nTODO:\n- Implement vi/vim editor\n- Add more Unix commands\n- Create mobile game prototypes\n',
                                'ideas.txt': 'Project Ideas\n=============\n\n1. Habit tracking app with gamification\n2. Mobile puzzle games\n3. Educational coding games for kids\n4. Terminal-based adventure game\n5. Productivity tools suite\n'
                            }
                        }
                    }
                },
                'root': {
                    '.bashrc': '# ~/.bashrc: root user bash configuration\n\nif [ -f /etc/bashrc ]; then\n    . /etc/bashrc\nfi\n\n# Root prompt in red\nPS1=\'\\[\\033[01;31m\\]\\u@\\h\\[\\033[00m\\]:\\w\\# \'\n\nalias ll=\'ls -la\'\nalias rm=\'rm -i\'\nalias cp=\'cp -i\'\nalias mv=\'mv -i\'\n',
                    '.bash_history': 'apt update\napt upgrade\nsystemctl status\nls -la /home\n',
                    '.profile': '# ~/.profile: root user profile\n\nif [ -n "$BASH_VERSION" ]; then\n    if [ -f "$HOME/.bashrc" ]; then\n        . "$HOME/.bashrc"\n    fi\nfi\n\nPATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin\n'
                },
                'var': {
                    'log': {
                        'syslog': 'Oct 22 10:15:23 ripline systemd[1]: Started System Logging Service.\nOct 22 10:15:24 ripline systemd[1]: Starting Network Manager...\nOct 22 10:15:25 ripline NetworkManager[512]: NetworkManager (version 1.30.0) is starting...\n',
                        'auth.log': 'Oct 22 10:15:30 ripline sshd[1024]: Server listening on 0.0.0.0 port 22.\nOct 22 10:16:45 ripline sshd[1156]: Accepted publickey for kmitnick from 192.168.1.100\n',
                        'kern.log': 'Oct 22 10:15:20 ripline kernel: [    0.000000] Linux version 5.15.0-ripline\nOct 22 10:15:20 ripline kernel: [    0.000000] Command line: BOOT_IMAGE=/vmlinuz root=/dev/sda1\n'
                    },
                    'www': {
                        'html': {
                            'index.html': '<!DOCTYPE html>\n<html>\n<head><title>Welcome to nginx</title></head>\n<body>\n<h1>Welcome to nginx on RIPLINE!</h1>\n</body>\n</html>\n'
                        }
                    }
                },
                'usr': {
                    'bin': {
                        'python3': '[binary]',
                        'git': '[binary]',
                        'vim': '[binary]',
                        'node': '[binary]',
                        'npm': '[binary]'
                    },
                    'share': {
                        'doc': {
                            'README': 'This directory contains documentation for installed packages.\n'
                        }
                    }
                },
                'tmp': {},
                'opt': {},
                'srv': {},
                'mnt': {}
            }
        };

        // Try to load from localStorage
        let savedFS = this.loadFromStorage('ripline_filesystem');
        const savedPath = this.loadFromStorage('ripline_current_path');
        const savedUser = this.loadFromStorage('ripline_current_user');

        // Migrate old structure if needed
        if (savedFS && savedFS['/'] && savedFS['/'].home) {
            // Check if we have old /home/kmitnick instead of /home/user/kmitnick
            if (savedFS['/'].home.kmitnick && !savedFS['/'].home.user) {
                console.log('Migrating filesystem structure to /home/user/kmitnick...');
                savedFS['/'].home.user = { kmitnick: savedFS['/'].home.kmitnick };
                delete savedFS['/'].home.kmitnick;
                this.saveToStorage('ripline_filesystem', savedFS);
            }
            // Add root directory if missing
            if (!savedFS['/'].root) {
                savedFS['/'].root = {};
                this.saveToStorage('ripline_filesystem', savedFS);
            }
        }

        this.fileSystem = savedFS || defaultFileSystem;

        // Always start as kmitnick on page load
        this.currentUser = 'kmitnick';
        this.currentPath = '/home/user/kmitnick';

        // User stack for exit command (don't persist this)
        this.userStack = [];

        this.environment = {
            'USER': this.currentUser,
            'HOME': '/home/user/kmitnick',
            'PWD': this.currentPath,
            'PATH': '/usr/local/bin:/usr/bin:/bin',
            'SHELL': '/bin/bash'
        };
        this.commandHistory = [];

        // Save initial state
        if (!savedFS) {
            this.saveToStorage('ripline_filesystem', this.fileSystem);
        }
        // Always reset to kmitnick's home on page load
        this.saveToStorage('ripline_current_path', this.currentPath);
        this.saveToStorage('ripline_current_user', this.currentUser);
    }

    // LocalStorage helpers
    saveToStorage(key, data) {
        try {
            localStorage.setItem(key, JSON.stringify(data));
        } catch (e) {
            console.error('Failed to save to localStorage:', e);
        }
    }

    loadFromStorage(key) {
        try {
            const data = localStorage.getItem(key);
            return data ? JSON.parse(data) : null;
        } catch (e) {
            console.error('Failed to load from localStorage:', e);
            return null;
        }
    }

    // Persist filesystem changes
    persistFileSystem() {
        this.saveToStorage('ripline_filesystem', this.fileSystem);
    }

    // Persist current path
    persistCurrentPath() {
        this.saveToStorage('ripline_current_path', this.currentPath);
    }

    // Persist current user
    persistCurrentUser() {
        this.saveToStorage('ripline_current_user', this.currentUser);
    }

    // Get owner of a file/directory based on path
    getOwner(path) {
        if (path.startsWith('/home/user/kmitnick') || path === '/home/user/kmitnick' || path === '/home/user') {
            return { user: 'kmitnick', group: 'kmitnick' };
        }
        return { user: 'root', group: 'root' };
    }

    // Check if current user has write permission to a path
    canWrite(path) {
        // Root can write anywhere
        if (this.currentUser === 'root') {
            return true;
        }

        // kmitnick can only write in their home directory
        if (this.currentUser === 'kmitnick') {
            const fullPath = this.resolvePath(path);
            return fullPath.startsWith('/home/user/kmitnick');
        }

        return false;
    }

    // Helper: Navigate filesystem
    resolvePath(path) {
        // Expand ~ to home directory
        if (path.startsWith('~')) {
            path = this.environment.HOME + path.slice(1);
        }

        if (path.startsWith('/')) {
            return path;
        }
        const parts = this.currentPath.split('/').filter(p => p);
        const newParts = path.split('/').filter(p => p);

        for (const part of newParts) {
            if (part === '..') {
                parts.pop();
            } else if (part !== '.') {
                parts.push(part);
            }
        }
        return '/' + parts.join('/');
    }

    getNode(path) {
        const fullPath = this.resolvePath(path);
        const parts = fullPath.split('/').filter(p => p);
        let current = this.fileSystem['/'];

        for (const part of parts) {
            if (current && typeof current === 'object' && part in current) {
                current = current[part];
            } else {
                return null;
            }
        }
        return current;
    }

    // Command implementations
    commands = {
        help: () => {
            return `Available commands:
  help          - Show this help message
  ls            - List directory contents
  cd [dir]      - Change directory
  pwd           - Print working directory
  cat [file]    - Display file contents
  echo [text]   - Display a line of text
  clear         - Clear the terminal
  whoami        - Print current user
  date          - Display current date and time
  uname         - Print system information
  env           - Print environment variables
  history       - Show command history
  mkdir [dir]   - Create a directory
  touch [file]  - Create an empty file
  rm [file]     - Remove a file
  tree          - Display directory tree
  vi/vim [file] - Edit a file
  exit          - Return to previous user session

Type any command to try it out!`;
        },

        ls: (args) => {
            // Parse flags and path
            let showHidden = false;
            let longFormat = false;
            let humanReadable = false;
            let targetPath = null;

            for (const arg of args) {
                if (arg.startsWith('-')) {
                    // Parse flags
                    if (arg.includes('a')) showHidden = true;
                    if (arg.includes('l')) longFormat = true;
                    if (arg.includes('h')) humanReadable = true;
                } else {
                    targetPath = arg;
                }
            }

            const path = targetPath || this.currentPath;
            const node = this.getNode(path);

            if (!node) {
                return `ls: cannot access '${targetPath || '.'}': No such file or directory`;
            }

            if (typeof node === 'string') {
                return targetPath || '.';
            }

            let entries = Object.keys(node);

            // Filter hidden files unless -a is specified
            if (!showHidden) {
                entries = entries.filter(name => !name.startsWith('.'));
            }

            if (entries.length === 0) {
                return '';
            }

            // Sort entries (directories first, then alphabetically)
            entries.sort((a, b) => {
                const aIsDir = typeof node[a] === 'object';
                const bIsDir = typeof node[b] === 'object';

                if (aIsDir && !bIsDir) return -1;
                if (!aIsDir && bIsDir) return 1;
                return a.localeCompare(b);
            });

            if (longFormat) {
                // Long format listing
                return entries.map(name => {
                    const isDir = typeof node[name] === 'object';
                    const perms = isDir ? 'drwxr-xr-x' : '-rw-r--r--';
                    const links = isDir ? '2' : '1';

                    // Determine ownership based on file path
                    const filePath = path === '/' ? `/${name}` : `${path}/${name}`;
                    const owner = this.getOwner(filePath);
                    const user = owner.user;
                    const group = owner.group;

                    let size;
                    if (isDir) {
                        size = '4096';
                    } else {
                        const bytes = node[name].length;
                        if (humanReadable) {
                            if (bytes < 1024) size = bytes + 'B';
                            else if (bytes < 1024 * 1024) size = Math.round(bytes / 1024) + 'K';
                            else size = Math.round(bytes / (1024 * 1024)) + 'M';
                        } else {
                            size = bytes.toString();
                        }
                    }

                    const date = new Date().toLocaleDateString('en-US', {
                        month: 'short',
                        day: 'numeric',
                        hour: '2-digit',
                        minute: '2-digit'
                    });

                    return `${perms} ${links} ${user.padEnd(8)} ${group.padEnd(8)} ${size.padStart(humanReadable ? 5 : 8)} ${date} ${name}`;
                }).join('\n');
            } else {
                // Simple format
                return entries.map(name => {
                    const isDir = typeof node[name] === 'object';
                    return isDir ? `${name}/` : name;
                }).join('  ');
            }
        },

        cd: (args) => {
            if (!args[0]) {
                this.currentPath = this.environment.HOME;
                this.environment.PWD = this.currentPath;
                this.persistCurrentPath();
                return '';
            }

            const newPath = this.resolvePath(args[0]);
            const node = this.getNode(newPath);

            if (!node) {
                return `cd: ${args[0]}: No such file or directory`;
            }

            if (typeof node === 'string') {
                return `cd: ${args[0]}: Not a directory`;
            }

            this.currentPath = newPath;
            this.environment.PWD = this.currentPath;
            this.persistCurrentPath();
            return '';
        },

        pwd: () => {
            return this.currentPath;
        },

        cat: (args) => {
            if (!args[0]) {
                return 'cat: missing file operand';
            }

            const node = this.getNode(args[0]);

            if (!node) {
                return `cat: ${args[0]}: No such file or directory`;
            }

            if (typeof node !== 'string') {
                return `cat: ${args[0]}: Is a directory`;
            }

            return node;
        },

        echo: (args) => {
            // Join arguments and remove surrounding quotes
            const text = args.join(' ');
            // Remove surrounding single or double quotes
            return text.replace(/^["']|["']$/g, '');
        },

        clear: () => {
            return '__CLEAR__';
        },

        whoami: () => {
            return this.environment.USER;
        },

        date: () => {
            return new Date().toString();
        },

        uname: (args) => {
            if (args.includes('-a')) {
                return 'RIPLINE 1.0.0 RIPLINE Terminal x86_64 GNU/JavaScript';
            }
            return 'RIPLINE';
        },

        env: () => {
            return Object.entries(this.environment)
                .map(([key, value]) => `${key}=${value}`)
                .join('\n');
        },

        history: () => {
            return this.commandHistory
                .map((cmd, i) => `${i + 1}  ${cmd}`)
                .join('\n');
        },

        mkdir: (args) => {
            if (!args[0]) {
                return 'mkdir: missing operand';
            }

            const path = this.resolvePath(args[0]);

            // Check write permission
            if (!this.canWrite(path)) {
                return `mkdir: cannot create directory '${args[0]}': Permission denied`;
            }

            const parts = path.split('/').filter(p => p);
            const dirName = parts.pop();
            const parentPath = '/' + parts.join('/');
            const parent = this.getNode(parentPath);

            if (!parent) {
                return `mkdir: cannot create directory '${args[0]}': No such file or directory`;
            }

            if (typeof parent !== 'object') {
                return `mkdir: cannot create directory '${args[0]}': Not a directory`;
            }

            if (dirName in parent) {
                return `mkdir: cannot create directory '${args[0]}': File exists`;
            }

            parent[dirName] = {};
            this.persistFileSystem();
            return '';
        },

        touch: (args) => {
            if (!args[0]) {
                return 'touch: missing file operand';
            }

            const path = this.resolvePath(args[0]);

            // Check write permission
            if (!this.canWrite(path)) {
                return `touch: cannot touch '${args[0]}': Permission denied`;
            }

            const parts = path.split('/').filter(p => p);
            const fileName = parts.pop();
            const parentPath = '/' + parts.join('/');
            const parent = this.getNode(parentPath);

            if (!parent) {
                return `touch: cannot touch '${args[0]}': No such file or directory`;
            }

            if (typeof parent !== 'object') {
                return `touch: cannot touch '${args[0]}': Not a directory`;
            }

            if (!(fileName in parent)) {
                parent[fileName] = '';
            }
            this.persistFileSystem();
            return '';
        },

        rm: (args) => {
            if (!args[0]) {
                return 'rm: missing operand';
            }

            // Parse flags
            let recursive = false;
            let force = false;
            let verbose = false;
            const targets = [];

            for (const arg of args) {
                if (arg.startsWith('-')) {
                    if (arg.includes('r') || arg.includes('R')) recursive = true;
                    if (arg.includes('f')) force = true;
                    if (arg.includes('v')) verbose = true;
                } else {
                    targets.push(arg);
                }
            }

            if (targets.length === 0) {
                return 'rm: missing operand';
            }

            const errors = [];
            const removed = [];

            // Process each target
            for (const target of targets) {
                // Check for wildcards
                if (target.includes('*')) {
                    // Handle wildcard matching
                    const dirPath = target.includes('/') ? target.substring(0, target.lastIndexOf('/')) : '.';
                    const pattern = target.includes('/') ? target.substring(target.lastIndexOf('/') + 1) : target;

                    const resolvedDir = this.resolvePath(dirPath);
                    const parentNode = this.getNode(resolvedDir);

                    if (!parentNode || typeof parentNode !== 'object') {
                        if (!force) {
                            errors.push(`rm: cannot remove '${target}': No such file or directory`);
                        }
                        continue;
                    }

                    // Convert wildcard pattern to regex
                    const regexPattern = '^' + pattern.replace(/\*/g, '.*').replace(/\?/g, '.') + '$';
                    const regex = new RegExp(regexPattern);

                    // Find matching files/directories
                    const matches = Object.keys(parentNode).filter(name => regex.test(name));

                    if (matches.length === 0 && !force) {
                        errors.push(`rm: cannot remove '${target}': No such file or directory`);
                        continue;
                    }

                    // Remove each match
                    for (const match of matches) {
                        const matchPath = resolvedDir === '/' ? `/${match}` : `${resolvedDir}/${match}`;

                        // Check write permission
                        if (!this.canWrite(matchPath)) {
                            if (!force) {
                                errors.push(`rm: cannot remove '${match}': Permission denied`);
                            }
                            continue;
                        }

                        const isDir = typeof parentNode[match] === 'object';

                        if (isDir && !recursive) {
                            if (!force) {
                                errors.push(`rm: cannot remove '${match}': Is a directory`);
                            }
                            continue;
                        }

                        delete parentNode[match];
                        if (verbose) {
                            removed.push(`removed '${dirPath === '.' ? match : dirPath + '/' + match}'`);
                        }
                    }
                } else {
                    // Single file/directory removal
                    const path = this.resolvePath(target);

                    // Check write permission
                    if (!this.canWrite(path)) {
                        if (!force) {
                            errors.push(`rm: cannot remove '${target}': Permission denied`);
                        }
                        continue;
                    }

                    const parts = path.split('/').filter(p => p);
                    const fileName = parts.pop();
                    const parentPath = '/' + parts.join('/');
                    const parent = this.getNode(parentPath);

                    if (!parent || !(fileName in parent)) {
                        if (!force) {
                            errors.push(`rm: cannot remove '${target}': No such file or directory`);
                        }
                        continue;
                    }

                    const isDir = typeof parent[fileName] === 'object';

                    if (isDir && !recursive) {
                        if (!force) {
                            errors.push(`rm: cannot remove '${target}': Is a directory`);
                        }
                        continue;
                    }

                    delete parent[fileName];
                    if (verbose) {
                        removed.push(`removed '${target}'`);
                    }
                }
            }

            this.persistFileSystem();

            // Build output
            let output = '';
            if (verbose && removed.length > 0) {
                output = removed.join('\n');
            }
            if (errors.length > 0) {
                if (output) output += '\n';
                output += errors.join('\n');
            }

            return output;
        },

        tree: () => {
            const buildTree = (node, prefix = '', isLast = true) => {
                let result = '';
                const entries = Object.entries(node);

                entries.forEach(([name, value], index) => {
                    const isLastEntry = index === entries.length - 1;
                    const connector = isLastEntry ? '└── ' : '├── ';
                    const isDir = typeof value === 'object';

                    result += prefix + connector + name + (isDir ? '/\n' : '\n');

                    if (isDir) {
                        const newPrefix = prefix + (isLastEntry ? '    ' : '│   ');
                        result += buildTree(value, newPrefix, isLastEntry);
                    }
                });

                return result;
            };

            const node = this.getNode(this.currentPath);
            return this.currentPath + '/\n' + buildTree(node);
        },

        vi: (args) => {
            return this.openEditor(args[0] || 'untitled');
        },

        vim: (args) => {
            return this.openEditor(args[0] || 'untitled');
        },

        su: (args) => {
            const targetUser = args[0] || 'root';

            if (targetUser !== 'root' && targetUser !== 'kmitnick') {
                return `su: user ${targetUser} does not exist`;
            }

            // Push current user to stack before switching
            this.userStack.push({
                user: this.currentUser,
                home: this.environment.HOME,
                path: this.currentPath
            });

            this.currentUser = targetUser;
            this.environment.USER = targetUser;
            this.environment.HOME = targetUser === 'root' ? '/root' : '/home/user/kmitnick';

            // Change to home directory on user switch
            this.currentPath = this.environment.HOME;
            this.environment.PWD = this.currentPath;

            this.persistCurrentUser();
            this.persistCurrentPath();

            return `__USER_SWITCHED__:${targetUser}`;
        },

        sudo: (args) => {
            // Handle "sudo su" specifically
            if (args[0] === 'su') {
                return this.commands.su.call(this, args.slice(1));
            }

            // For other sudo commands, just run as current user
            // (We could implement privilege elevation here if needed)
            const command = args[0];
            const cmdArgs = args.slice(1);

            if (command in this.commands) {
                return this.commands[command].call(this, cmdArgs);
            } else {
                return `sudo: ${command}: command not found`;
            }
        },

        reset: (args) => {
            if (args[0] === '--filesystem' || args[0] === '-f') {
                // Clear filesystem from localStorage
                localStorage.removeItem('ripline_filesystem');
                localStorage.removeItem('ripline_current_path');
                localStorage.removeItem('ripline_current_user');
                return 'Filesystem reset. Please reload the page.';
            }
            return 'Usage: reset --filesystem (or -f) to reset the filesystem';
        },

        exit: () => {
            // Pop the previous user from the stack
            if (this.userStack.length === 0) {
                return 'exit: no other user session to return to';
            }

            const previousUser = this.userStack.pop();
            this.currentUser = previousUser.user;
            this.environment.USER = previousUser.user;
            this.environment.HOME = previousUser.home;
            this.currentPath = previousUser.path;
            this.environment.PWD = this.currentPath;

            this.persistCurrentUser();
            this.persistCurrentPath();

            return `__USER_SWITCHED__:${previousUser.user}`;
        }
    };

    execute(commandLine) {
        if (!commandLine.trim()) {
            return '';
        }

        // Add to history
        this.commandHistory.push(commandLine);

        // Check for output redirection (> or >>)
        let redirectMode = null;
        let redirectFile = null;
        let actualCommand = commandLine;

        // Parse redirection operators
        const appendMatch = commandLine.match(/^(.+?)\s*>>\s*(.+)$/);
        const overwriteMatch = commandLine.match(/^(.+?)\s*>\s*(.+)$/);

        if (appendMatch) {
            redirectMode = 'append';
            actualCommand = appendMatch[1].trim();
            redirectFile = appendMatch[2].trim();
        } else if (overwriteMatch) {
            redirectMode = 'overwrite';
            actualCommand = overwriteMatch[1].trim();
            redirectFile = overwriteMatch[2].trim();
        }

        // Parse command and arguments
        const parts = actualCommand.trim().split(/\s+/);
        const command = parts[0];
        const args = parts.slice(1);

        // Execute the command
        let output = '';
        if (command in this.commands) {
            try {
                output = this.commands[command].call(this, args);
            } catch (error) {
                return `Error executing ${command}: ${error.message}`;
            }
        } else {
            return `${command}: command not found`;
        }

        // Handle redirection
        if (redirectMode && redirectFile) {
            const writeResult = this.writeToFile(redirectFile, output, redirectMode);
            if (writeResult) {
                return writeResult; // Error message
            }
            return ''; // Success - no output
        }

        return output;
    }

    writeToFile(filePath, content, mode) {
        // Resolve the file path
        const fullPath = this.resolvePath(filePath);
        const parts = fullPath.split('/').filter(p => p);
        const fileName = parts.pop();
        const parentPath = '/' + parts.join('/');
        const parent = this.getNode(parentPath);

        if (!parent) {
            return `bash: ${filePath}: No such file or directory`;
        }

        if (typeof parent !== 'object') {
            return `bash: ${filePath}: Not a directory`;
        }

        // Check if target exists and is a directory
        if (fileName in parent && typeof parent[fileName] === 'object') {
            return `bash: ${filePath}: Is a directory`;
        }

        // Write to file
        if (mode === 'append' && fileName in parent) {
            parent[fileName] += content;
        } else {
            parent[fileName] = content;
        }

        this.persistFileSystem();
        return null; // Success
    }

    getCurrentPath() {
        return this.currentPath;
    }

    getCurrentUser() {
        return this.currentUser;
    }

    openEditor(filename) {
        // Resolve the file path
        const fullPath = this.resolvePath(filename);
        const node = this.getNode(fullPath);

        let content = '';
        if (node && typeof node === 'string') {
            content = node;
        }

        // Create and open the vi editor
        const saveCallback = (filename, content) => {
            // Write the file back to the filesystem
            const result = this.writeToFile(filename, content, 'overwrite');
            if (!result) {
                // Success
                this.persistFileSystem();
            }
        };

        const exitCallback = () => {
            // Re-enable terminal after editor closes
            if (window.enableTerminal) {
                window.enableTerminal();
            }
        };

        // Disable terminal while editor is open
        if (window.disableTerminal) {
            window.disableTerminal();
        }

        new ViEditor(filename, content, saveCallback, exitCallback);

        return '__VI_OPENED__'; // Special return to prevent output
    }

    // Tab completion helper
    getCompletions(partial) {
        const parts = partial.trim().split(/\s+/);

        // If no space, complete command names
        if (parts.length === 1) {
            const prefix = parts[0];
            const commands = Object.keys(this.commands).filter(cmd => cmd.startsWith(prefix));
            return { type: 'command', matches: commands, prefix };
        }

        // If space exists, complete file/directory paths
        const command = parts[0];
        const pathPrefix = parts[parts.length - 1];

        // Get directory to search
        let searchDir = this.currentPath;
        let filePrefix = pathPrefix;

        if (pathPrefix.includes('/')) {
            const lastSlash = pathPrefix.lastIndexOf('/');
            const dirPart = pathPrefix.substring(0, lastSlash + 1);
            filePrefix = pathPrefix.substring(lastSlash + 1);
            searchDir = this.resolvePath(dirPart);
        }

        const node = this.getNode(searchDir);
        if (!node || typeof node !== 'object') {
            return { type: 'path', matches: [], prefix: pathPrefix };
        }

        // Find matching files/directories
        const matches = Object.keys(node)
            .filter(name => name.startsWith(filePrefix))
            .map(name => {
                const isDir = typeof node[name] === 'object';
                return isDir ? name + '/' : name;
            });

        return { type: 'path', matches, prefix: pathPrefix, filePrefix };
    }
}

// Make available in browser
if (typeof window !== 'undefined') {
    window.UnixEmulator = UnixEmulator;
}

// Export for Node.js if needed
if (typeof module !== 'undefined' && module.exports) {
    module.exports = UnixEmulator;
}
